% 8/6/13
% findTrajLoad1D.m
% generate optimal trajectory, assuming only a 1D load
%
% Dependencies: findContConstraints.m, findFixedConstraints.m,
%   findDerivativeCoeff.m, findCostMatrix.m, translateLoadConst.m
%
% inputs:
%   r: integer, derivative to minimize in cost function
%   n: integer, order of desired trajectory
%   m: integer, number of pieces in trajectory
%   d: integer, number of dimensions
%   tDes: (m+1) x 1 vector, desired times of arrival at keyframes
%   posDes: r x m x d matrix, desired positions and/or derivatives at keyframes,
%       Inf represents unconstrained values
%       each row i is the value the (i-1)th derivative of column j for
%       dimenison k
%   TDes: desired tensions at keyframes
%   g: constant, gravity
%   len, mL, mQ: constants, length of cable
% outputs:
%   xTL: (n+1) x mNew x d matrix, where row i contains the ith coefficient for
%       the jth trajectory in dimension k
%       xTL is nondimensionalized in time
%       trajectory for load
%   xTQ: (n+1) x mNew x d matrix, where row i contains the ith coefficient for
%       the jth trajectory in dimension k
%       trajectory for quad, only exists when system is in mode 2
%       all coefficients 0 otherwise
%   mode: a x 3 vector, logs mode switches
%       column 1 indicates keyframe switch occurs, column 2 is last mode,
%           column 3 is new mode (redundant, but just to be explicit)
%       1 indicates mode where cable is taut, trajectory is for load
%       2 indicates mode where cable is slack, trajectory is for quadrotor
%   tDesN: (m+1)x1 vector, time arrival at keyframes, could have changed if position of T =
%       0 didn't match time 
%   posDesN: r x m x d matrix, endpoint conditions for load at keyframes after
%       optimization


function [xTL, xTQ, mode, tDesN, posDesN] = findTrajLoad1D(r, n, m, d, tDes, posDes, TDes, g, len, mL, mQ)


% check that we are dealing with a 1D problem
if d ~= 1,
    error('not a 1D problem!')
end



% use nondimensionalized time
t0 = 0;
t1 = 1;


% we seek trajectories
% x1(t) = cx1,n*t^n + cx1,n-1*t^(n-1) + ... cx1,0;
% ...
% xm(t) = cxm,n*t^n + cxm,n-1*t^(n-1) + ... cxm,0;
% ...
% y1(t) = cy1,n*t^n + cy1,n-1*t^(n-1) + ... cy1,0;
% ...
% z1(t) = cz1,n*t^n + cz1,n-1*t^(n-1) + ... cz1,0;
% ... for d dimensions
% form the state vector x as:
% x = [cx1,(n) cx1,(n-1) ... cx1,1 cx1,0 cx2,n cx2,(n-1) ... cx2,1 cx2,0 .... cxm,0 ....
%       cy1,(n) cy1,(n-1) ... cy1,1 cy1,0 cy2,n cy2,(n-1) ... cy2,1 cy2,0 .... cym,0 ....
%       cz1,(n) cz1,(n-1) ... cz1,1 cz1,0 cz2,n cz2,(n-1) ... cz2,1 cz2,0 .... czm,0]


% these represent the quadrotor trajectory

 
%%%
% construct cost matrix Q
Q_opt = [];

for dim = 1:d,
    
    Q_joint = zeros(m*(n+1));
    for i = 1:m,
        Q = findCostMatrix(n, r, t0, t1); % find cost matrix for each segment
        
        Q_joint(2*r*(i-1)+1:2*r*i, (n+1)*(i-1)+1:(n+1)*i) = 1./((tDes(i+1, 1)-tDes(i, 1))^(2*r)).*Q; %put in block diagonal matrix
    end
    
    % put each dimension's Q_joint into a block diagonal matrix
    Q_opt = blkdiag(Q_opt, Q_joint);
end



[posDesQ, tDesQ, modes] = translateLoadConst(r, n, m, d, tDes, posDes, TDes, g, len, mL, mQ);






end







